import "util.scrypt";

/**
 * A improved token protocol based on UTXO model
 */
contract Token {
      PubKey issuerPubKey;

      constructor(PubKey issuerPubKey) {
          this.issuerPubKey = issuerPubKey;
      }

      function tokenSatoshiBytes(): bytes {
        return num2bin(Util.TokenSatoshi, Util.OutputValueLen);
      }

      function checkPreimage(bytes txPreimage, SigHashType sigHashType) : bool {
        // The following arguments can be generated using sample code at
        // https://gist.github.com/scrypt-sv/f6882be580780a88984cee75dd1564c4.js
        PrivKey privKey = PrivKey(0x621de38d9af72be8585d19584e3954d3fd0dc9752bb9f9fb28c4f9ed7c1e40ea);
        PubKey pubKey = PubKey(b'02773aca113a3217b67a95d5b78b69bb6386ed443ea5decf0ba92c00d179291921');
            // invK is the modular inverse of k, the ephemeral key
        int invK = 0xa2103f96554aba49bbf581738d3b5a38c5a44b6238ffb54cfcca65b8c87ddc08;
            // r is x coordinate of R, which is kG
        int r = 0x00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60;
            // rBigEndian is the signed magnitude representation of r, in big endian
        bytes rBigEndian = b'00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60';

        // this ensures the preimage is for the current tx
        return Tx.checkPreimageAdvanced(txPreimage, privKey, pubKey, invK, r, rBigEndian, sigHashType);
      } 

      public function initiate(Sig issuerSig, Ripemd160 ownerPKH, bytes contractId, Ripemd160 changePKH, int changeSatoshi, bytes txPreimage) {
        // this ensures the preimage is for the current tx
        SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
        require(this.checkPreimage(txPreimage, sigHashType));

        // authorize
        require(checkSig(issuerSig,  this.issuerPubKey));
        
        //outpoint (32-byte hash + 4-byte little endian)
        bytes outpoint = Util.outpoint(txPreimage);
        require(outpoint == reverseBytes32(contractId) + num2bin(0, Util.IndexLen) );


        // read previous locking script: 
        // codePart + OP_RETURN + name(64bytes) + symbol(16bytes) + issuer(64bytes) + rule(1byte) + decimals(1byte) + initialSupply(8bytes)   = 154bytes
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);

        int tokenStart = scriptLen - Util.OutputValueLen;
        int initialSupply = unpack(lockingScript[tokenStart : ]);

        // write new locking script
        // codePart + OP_RETURN + contractId(32bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 60bytes
        bytes lockingScript_ = lockingScript[: 154] + contractId + ownerPKH + num2bin(initialSupply, Util.OutputValueLen);
        bytes output = this.tokenSatoshiBytes() + Util.writeVarint(lockingScript_);

     		// Expect the notify output
        bytes notifyScript = Util.buildPublicKeyHashScript(ownerPKH);
        bytes notifyOutput = this.tokenSatoshiBytes() + Util.writeVarint(notifyScript);
        output = output + notifyOutput;

        if(changeSatoshi != 0 ) {
            // the change output
            bytes changeScript = Util.buildPublicKeyHashScript(changePKH);
            bytes changeOutput = num2bin(changeSatoshi, Util.OutputValueLen) + Util.writeVarint(changeScript);
            output = output + changeOutput;
        }

        require(hash256(output) == Util.hashOutputs(txPreimage));
      }

      public function transfer(Sig senderSig, PubKey senderPubKey, Ripemd160 receiverPKH, bytes txPreimage) {
        // this ensures the preimage is for the current tx
        SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.SINGLE | SigHash.FORKID;
        require(this.checkPreimage(txPreimage, sigHashType));

        // read previous locking script: 
        // codePart + OP_RETURN + contractId(32bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 60bytes
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);

        int tokenStart = scriptLen - Util.OutputValueLen;
        int tokenAmount = unpack(lockingScript[tokenStart : ]);

        // constant part of locking script: upto OP_RETURN
        int hashStart = scriptLen - Util.PubKeyHashLen - Util.OutputValueLen;
        Ripemd160 ownerHash = Ripemd160(lockingScript[hashStart: tokenStart]);

        // authorize
        require(hash160(senderPubKey) == ownerHash);
        require(checkSig(senderSig, senderPubKey));

        // write new locking script
        bytes lockingScript_ = lockingScript[: hashStart] + receiverPKH + num2bin(tokenAmount, Util.OutputValueLen);
        bytes output = this.tokenSatoshiBytes() + Util.writeVarint(lockingScript_);
        require(hash256(output) == Util.hashOutputs(txPreimage));
    }

    public function split(Sig senderSig, PubKey senderPubKey, Ripemd160 receiverPKH, int tokenAmount0, Ripemd160 changeTokenPKH, int tokenAmount1, Ripemd160 changeSatoshiPKH, int changeSatoshi, bytes txPreimage) {
        require(tokenAmount0 > 0);
        require(tokenAmount1 > 0);
        
        // this ensures the preimage is for the current tx
        SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
        require(this.checkPreimage(txPreimage, sigHashType));

        // read previous locking script: 
        // codePart + OP_RETURN + contractId(32bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 60bytes
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);

        int tokenStart = scriptLen - Util.OutputValueLen;
        int tokenAmount = unpack(lockingScript[tokenStart : ]);
        require(tokenAmount == tokenAmount0 + tokenAmount1);

        // constant part of locking script: upto OP_RETURN
        int hashStart = scriptLen - Util.PubKeyHashLen - Util.OutputValueLen;
        Ripemd160 ownerHash = Ripemd160(lockingScript[hashStart: tokenStart]);

        // authorize
        require(hash160(senderPubKey) == ownerHash);
        require(checkSig(senderSig, senderPubKey));
        
        bytes lockingScript0_ = lockingScript[: hashStart] + receiverPKH + num2bin(tokenAmount0, Util.OutputValueLen);
        bytes lockingScript1_ = lockingScript[: hashStart] + changeTokenPKH + num2bin(tokenAmount1, Util.OutputValueLen);

        //concatenating all ouputs
        bytes output0 = this.tokenSatoshiBytes() + Util.writeVarint(lockingScript0_);
        bytes output1 = this.tokenSatoshiBytes() + Util.writeVarint(lockingScript1_);
        bytes output = output0 + output1;

     		// Expect the notify output
        bytes notifyScript = Util.buildPublicKeyHashScript(receiverPKH);
        bytes notifyOutput = this.tokenSatoshiBytes() + Util.writeVarint(notifyScript);
        output = output + notifyOutput;

        if(changeSatoshi != 0 ) {
            // the change output
            bytes changeScript = Util.buildPublicKeyHashScript(changeSatoshiPKH);
            bytes changeOutput = num2bin(changeSatoshi, Util.OutputValueLen) + Util.writeVarint(changeScript);
            output = output + changeOutput;
        }

        require(hash256(output) == Util.hashOutputs(txPreimage));
    }


    // burn a token utxo back to normal bitcoins
    public function burn(Sig ownerSig, PubKey ownerPK, Ripemd160 changePKH, int changeSatoshi, bytes txPreimage) {
        SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;

        // this ensures the preimage is for the current tx
        require(this.checkPreimage(txPreimage, sigHashType));

        // read previous locking script: codePart + OP_RETURN + contractId(32bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) 
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);

        int tokenStart = scriptLen - Util.OutputValueLen;

        // constant part of locking script: upto OP_RETURN
        int hashStart = scriptLen - Util.PubKeyHashLen - Util.OutputValueLen;
        Ripemd160 ownerPKH = Ripemd160(lockingScript[hashStart: tokenStart]);

        // authorize
        require(hash160(ownerPK) == ownerPKH);
        require(checkSig(ownerSig, ownerPK));

        // send to a P2PKH script
        bytes lockingScript_ = Util.buildPublicKeyHashScript(changePKH);
    		bytes output = num2bin(changeSatoshi, Util.OutputValueLen) + Util.writeVarint(lockingScript_);
        require(hash256(output) == Util.hashOutputs(txPreimage));
    }
}