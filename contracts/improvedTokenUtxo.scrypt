import "util.scrypt";

/**
 * A improved token protocol based on UTXO model
 */
contract Token {
      PubKey issuerPubKey;
      int maxSupply;
      Ripemd160 witnessPKH;

      constructor(PubKey issuerPubKey, int maxSupply, Ripemd160 witnessPKH) {
          this.issuerPubKey = issuerPubKey;
          this.maxSupply = maxSupply;
          this.witnessPKH = witnessPKH;
      }

      function notifySatoshiBytes(): bytes {
        return num2bin(Util.NotifySatoshi, Util.OutputValueLen);
      }

      public function initiate(Sig issuerSig, Ripemd160 ownerPKH, Ripemd160 changePKH, int changeSatoshi, bytes txPreimage, int outValue) {
        // this ensures the preimage is for the current tx
        SigHashType sigHashType = SigHash.ALL | SigHash.FORKID;
        require(Util.checkPreimageSigHashType(txPreimage, sigHashType));
        // authorize
        require(checkSig(issuerSig,  this.issuerPubKey));
        
        //outpoint (32-byte hash + 4-byte little endian)
        bytes prevOutpoint = Util.outpoint(txPreimage);
        bytes contractId = reverseBytes32(prevOutpoint[ : 32]);
 
        // read genesis locking script: 
        // codePart + OP_RETURN + name(64bytes) + symbol(16bytes) + issuer(64bytes) + rule(1byte) + decimals(1byte) + initialSupply(8bytes) = 154bytes
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);

        int supplyStart = scriptLen - 8;
        int decimalsStart = supplyStart - 1;
        int ruleStart = decimalsStart - 1;
        int issuerStart = ruleStart - 64;
        int symbolStart = issuerStart - 16;
        int nameStart = symbolStart - 64;

        int dataLenStart = nameStart - 1;

        bytes initialSupply = lockingScript[supplyStart : ];

        bytes lockingScriptBody = lockingScript[ : dataLenStart ];

        bytes valueBytes = num2bin(outValue, Util.OutputValueLen);

        // write Token UTXO locking script
        // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 96bytes
        //bytes tokenData = initialSupply + initialSupply;
        bytes tokenData = contractId + prevOutpoint + ownerPKH + initialSupply;
        bytes tokenLockingScript = lockingScriptBody + num2bin(len(tokenData), 1) + tokenData; 
        bytes output0 = valueBytes + Util.writeVarint(tokenLockingScript);

        // write Baton UTXO locking script
        // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + totalSupply(8bytes) = 76bytes
        bytes batonData = contractId + prevOutpoint + initialSupply;
        //bytes batonData = initialSupply;
        bytes batonLockingScript = lockingScriptBody + num2bin(len(batonData), 1) + batonData;
        bytes output1 = valueBytes + Util.writeVarint(batonLockingScript);

     		// notify owner output
        bytes ownerNotifyScript = Util.buildPublicKeyHashScript(ownerPKH);
        bytes output2 = this.notifySatoshiBytes() + Util.writeVarint(ownerNotifyScript);

     		// notify witness output
        bytes witnessNotifyScript = Util.buildPublicKeyHashScript(this.witnessPKH);
        bytes output3 = this.notifySatoshiBytes() + Util.writeVarint(witnessNotifyScript);

        // the change output
        bytes output4 = changeSatoshi != 0 ? num2bin(changeSatoshi, Util.OutputValueLen) + Util.writeVarint(Util.buildPublicKeyHashScript(changePKH)) : b'';

		    Sha256 hashOutputs = hash256(output0 + output1 + output2 + output3 + output4);
        require(hashOutputs == Util.hashOutputs(txPreimage));
      }

      public function issue(Sig issuerSig, Ripemd160 ownerPKH, int supply, Ripemd160 changePKH, int changeSatoshi, bytes txPreimage, int outValue) {
        require(supply > 0);

        // this ensures the preimage is for the current tx
        SigHashType sigHashType = SigHash.ALL | SigHash.FORKID;
        // SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
        require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

        // authorize
        require(checkSig(issuerSig,  this.issuerPubKey));
        
        //outpoint (32-byte hash + 4-byte little endian)
        bytes prevOutpoint = Util.outpoint(txPreimage);

        // read previous Baton locking script: 
        // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + totalSupply(8bytes) = 96bytes
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);

        int totalSupplyStart = scriptLen - 8;
        int prevOutpointStart = totalSupplyStart - 36;
        int contractIdStart = prevOutpointStart - 32;
        int dataLenStart = contractIdStart - 1;

        bytes lockingScriptBody = lockingScript[: dataLenStart];
        bytes contractId = lockingScript[contractIdStart : prevOutpointStart];

        int totalSupply = unpack(lockingScript[totalSupplyStart : ]) + supply;
        require( this.maxSupply == 0 || totalSupply <= this.maxSupply );

        bytes valueBytes = num2bin(outValue, Util.OutputValueLen);

        // write Token UTXO locking script
        // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 96bytes
        bytes tokenData = contractId + prevOutpoint + ownerPKH + num2bin(supply, Util.OutputValueLen);
        bytes tokenLockingScript = lockingScriptBody + num2bin(len(tokenData), 1) + tokenData; 

        bytes output0 = valueBytes + Util.writeVarint(tokenLockingScript);

        // write Baton UTXO locking script
        // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + totalSupply(8bytes) = 76bytes
        bytes batonData = contractId + prevOutpoint + num2bin(totalSupply, Util.OutputValueLen);
        bytes batonLockingScript = lockingScriptBody + num2bin(len(batonData), 1) + batonData;
        bytes output1 = valueBytes + Util.writeVarint(batonLockingScript);

     		// Expect the notify output
        bytes ownerNotifyScript = Util.buildPublicKeyHashScript(ownerPKH);
        bytes output2 = this.notifySatoshiBytes() + Util.writeVarint(ownerNotifyScript);

     		// notify witness output
        bytes witnessNotifyScript = Util.buildPublicKeyHashScript(this.witnessPKH);
        bytes output3 = this.notifySatoshiBytes() + Util.writeVarint(witnessNotifyScript);

        // the change output
        bytes output4 = changeSatoshi != 0 ? num2bin(changeSatoshi, Util.OutputValueLen) + Util.writeVarint(Util.buildPublicKeyHashScript(changePKH)) : b'';

		    Sha256 hashOutputs = hash256(output0 + output1 + output2 + output3 + output4);
        require(hashOutputs == Util.hashOutputs(txPreimage));
      }

      // public function punish(bytes txPreimage, bytes prevTx, bytes prevPrevTx) {
      //   // this ensures the preimage is for the current tx
      //   SigHashType sigHashType = SigHash.ALL | SigHash.FORKID;
      //   require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

      //   //check value
      //   if(outValue != Util.value(txPreimage)) {
      //     exit(true);
      //   }

      //   // bytes outpoint = Util.outpoint(txPreimage);
      //   // bytes prevTxId = outpoint[ : 32];
      //   // require(hash256(prevTx) == prevTxId);
            
      //   // //outpoint (32-byte hash + 4-byte little endian)
      //   // bytes lockingScript = Util.scriptCode(txPreimage);
      //   // // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 96bytes
      //   // int scriptLen = len(lockingScript);
      //   // //prevOutpoint(36bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 64bytes
      //   // //ownerPkh(20bytes) + tokenAmount(8bytes) = 28bytes
      //   // bytes prevOutpoint = lockingScript[scriptLen - 64 : scriptLen - 28 ]; 
      //   // bytes prevPrevTxId = prevOutpoint[ : 32]
      //   // if(hash256(prevPrevTx) != prevPrevTxId) {
      //   //   exit(true);
      //   // }

      //   // //check tx size
      //   // if(len(prevPrevTx) <= len(txPreimage)) {
      //   //   exit(true);
      //   // }

      //   require(false);
      // }


      public function transfer(Sig senderSig, PubKey senderPubKey, Ripemd160 receiverPKH, bytes txPreimage, int outValue) {
        // this ensures the preimage is for the current tx
        SigHashType sigHashType = SigHash.SINGLE | SigHash.FORKID;
        require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

        // read UTXO Token locking script: 
        // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 96bytes
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);
        
        int tokenAmountStart = scriptLen - 8;
        int ownerPkhStart = tokenAmountStart - 20;
        int prevOutpointStart = ownerPkhStart - 36;
        
        bytes ownerPkhBytes = lockingScript[ownerPkhStart : tokenAmountStart];
        Ripemd160 ownerPKH = Ripemd160(ownerPkhBytes);

        // authorize
        require(hash160(senderPubKey) == ownerPKH);
        require(checkSig(senderSig, senderPubKey));
        require(ownerPKH != receiverPKH );

        int tokenAmount = unpack(lockingScript[tokenAmountStart : ]);
        bytes lockingScriptBody = lockingScript[ : prevOutpointStart]; 

        //outpoint (32-byte hash + 4-byte little endian)
        bytes prevOutpoint = Util.outpoint(txPreimage);

        bytes valueBytes = num2bin(outValue, Util.OutputValueLen);

        // write new locking script
        bytes tokenData = prevOutpoint + receiverPKH + num2bin(tokenAmount, Util.OutputValueLen);
        bytes tokenLockingScript = lockingScriptBody + tokenData;
        bytes output = valueBytes + Util.writeVarint(tokenLockingScript);

        require(hash256(output) == Util.hashOutputs(txPreimage));
    }

    public function split(Sig senderSig, PubKey senderPubKey, Ripemd160 receiverPKH, int receiverTokenAmount, int changeTokenAmount, Ripemd160 changeSatoshiPKH, int changeSatoshi, bytes txPreimage, int outValue) {
        require(receiverTokenAmount > 0);
        require(changeTokenAmount > 0);
        
        // this ensures the preimage is for the current tx
        SigHashType sigHashType = SigHash.ALL | SigHash.FORKID;
        require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

        // read UTXO Token locking script: 
        // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 96bytes
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);
        
        int tokenAmountStart = scriptLen - 8;
        int ownerPkhStart = tokenAmountStart - 20;
        int prevOutpointStart = ownerPkhStart - 36;
        
        bytes ownerPkhBytes = lockingScript[ownerPkhStart : tokenAmountStart];
        Ripemd160 ownerPKH = Ripemd160(ownerPkhBytes);

        // authorize
        require(hash160(senderPubKey) == ownerPKH);
        require(checkSig(senderSig, senderPubKey));
        require(ownerPKH != receiverPKH );

        int tokenAmount = unpack(lockingScript[tokenAmountStart : ]);
        require(tokenAmount == receiverTokenAmount + changeTokenAmount );

        bytes lockingScriptBody = lockingScript[ : prevOutpointStart]; 

        //outpoint (32-byte hash + 4-byte little endian)
        bytes prevOutpoint = Util.outpoint(txPreimage);

        bytes lockingScript0 = lockingScriptBody + prevOutpoint + receiverPKH + num2bin(receiverTokenAmount, Util.OutputValueLen);
        bytes lockingScript1 = lockingScriptBody + prevOutpoint + ownerPKH + num2bin(changeTokenAmount, Util.OutputValueLen);

        bytes valueBytes = num2bin(outValue, Util.OutputValueLen);

        //concatenating all ouputs
        bytes output0 = valueBytes + Util.writeVarint(lockingScript0);
        bytes output1 = valueBytes + Util.writeVarint(lockingScript1);

     		// Expect the notify output
        bytes notifyScript = Util.buildPublicKeyHashScript(receiverPKH);
        bytes output2 = this.notifySatoshiBytes() + Util.writeVarint(notifyScript);

        bytes output = output0 + output1 + output2;

        if(changeSatoshi != 0 ) {
            // the change output
            bytes changeScript = Util.buildPublicKeyHashScript(changeSatoshiPKH);
            output = output + num2bin(changeSatoshi, Util.OutputValueLen) + Util.writeVarint(changeScript);
        }

        require(hash256(output) == Util.hashOutputs(txPreimage));
    }


    // burn a token utxo back to normal bitcoins
    public function burn(Sig ownerSig, PubKey ownerPK, Ripemd160 changePKH, int changeSatoshi, bytes txPreimage, int outValue) {
        SigHashType sigHashType = SigHash.ALL | SigHash.FORKID;
        // this ensures the preimage is for the current tx
        require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

        //check value
        require(outValue == Util.value(txPreimage));

        // read previous locking script: 
        // codePart + OP_RETURN + contractId(32bytes) + prevOutpoint(36bytes) + ownerPkh(20bytes) + tokenAmount(8bytes) = 96bytes
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);

        int tokenAmountStart = scriptLen - 8;
        int ownerPkhStart = tokenAmountStart - 20;
        Ripemd160 ownerPKH = Ripemd160(lockingScript[ownerPkhStart: tokenAmountStart]);

        // authorize
        require(hash160(ownerPK) == ownerPKH);
        require(checkSig(ownerSig, ownerPK));

        // send to a P2PKH script
        bytes lockingScript_ = Util.buildPublicKeyHashScript(changePKH);
    		bytes output = num2bin(changeSatoshi, Util.OutputValueLen) + Util.writeVarint(lockingScript_);
        require(hash256(output) == Util.hashOutputs(txPreimage));
    }
}